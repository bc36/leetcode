### Array / List
* 与 ArrayList 相比, LinkedList 的增加和删除的操作效率更高, 而查找和修改的操作效率较低
    * 以下情况使用 ArrayList:
        * 频繁访问列表中的某一个元素.
        * 只需要在列表末尾进行添加和删除元素操作.
    * 以下情况使用 LinkedList:
        * 你需要通过循环迭代来访问列表中的某些元素.
        * 需要频繁的在列表开头, 中间, 末尾等位置进行添加和删除元素操作

### Map / Set
* HashSet 是无序的, HashSet 不是线程安全的, HashSet 基于 HashMap 来实现的
* 为什么申明方法一用的比较多?
    ```java
    Map<String> m = new HashMap<String>();
    HashMap<String> m = new HashMap<String>();
    // A1: 
    // 面向接口编程的体现. 如果都声明成第二种的形式, 接口还有什么用?
    // 声明成接口的形式, 后面的使用不管你类的实现, 比如说后面你发现HashMap不合适了, 你只需要修改一处就行
    // A2: 
    // 假设你一个函数中的参数是使用HashMap声明, 那当你想要修改为Hashtable时需要修改函数中的参数类型, 而使用Map就不会遇到这种问题
    // A3: 
    // 第一种声明方式是: 父类的引用指向子类的对象,是多态的一种表现形式; 第二种是: 使用本身引用
    // 第一种声明方式是实现了多态, 多态后就可以写出一段所有子类都通用的代码, 当添加新的子类时, 这段代码是不需要修改的.
    //      比方说: 父类Animal, 子类Cat, Dog
    //      如果使用第2行, 当改用Dog的时候, 那么第3行也需要改变
    //      1 Animal a = new Cat();
    //      2 Cat a = new Cat();
    //      3 a.someMethod();
    // 父类的引用指向子类的对象的好处: 多态, 动态链接, 向上转型. 方法的重写, 重载与动态连接构成多态性. 
    // Java之所以引入多态的概念, 原因之一是它在类的继承问题上和C++不同, 
    // 后者允许多继承, 这确实给其带来的非常强大的功能, 但是复杂的继承关系也给C++开发者带来了更大的麻烦, 
    // 为了规避风险, Java只允许单继承, 派生类与基类间有IS-A的关系(即“猫” is a "动物"). 
    // 这样做虽然保证了继承关系的简单明了, 但是势必在功能上有很大的限制, 
    // 所以, Java引入了多态性的概念以弥补这点的不足, 此外, 抽象类和接口也是解决单继承规定限制的重要手段. 
    // 同时, 多态也是面向对象编程的精髓所在
    ```
